C++
Date: 2007-11-17 16:13
Status: Draft


Sent at 3:41 PM on Tuesday
Malcolm: A question for you, Oh Mr C++ Oracle.


Matt: I'm not living up to this reputation
but I'll give it a go


Malcolm: Is void f() { func1(func2().c_str()); }; valid, assuming that func2 returns a std::string and fun1 wants a const char * ?
i.e. I'm asking at what point the temporary is deleted.


Matt: yes
The temporary is never deleted
But it might be destructed


Malcolm: Ahem. Yeah, that.


Matt: </pedant>


Malcolm: :-)
Right, but true.


Matt: It's valid
BUt will give our favourite "undefined results"


Malcolm: Grr.
Right, I thought that might be the case.
Because of evaluation order?


Matt: if func2() returns a std::string, then of course the compiler has to destroy it when the last valid "handle" (or whatever) goes
Hmm
Hang on
yes
func2() will make a temporary (we assume?)


Malcolm: Ah, but that might between the call to .c_str() and the call to func1().
(yes)


Matt: unless it's std::string& func2() const {}


Malcolm: Hah. It's not.
It returns std::string directly.


Matt: right, so it constructs an object
returns it to a temporary
which you then call c_str() on
and then (to the best of my knowledge) C++ can wipe its hands of it
sequence points


Malcolm: Right, I thought that might be the case.


Matt: that's the name


Malcolm: sequence points indeedly.
string tmp (func2());
func1(tmp.c_str());


Matt: I'm pretty sure it's the case that that's "invalid" (well you know)


Malcolm: works.


Matt: yeah
if possible, func1() to take const std::string& too?
then that can call func1(foo.c_str()) (overloaded)
unlikely


Malcolm: func1() is actually printf (kinda), so no.


Matt: When calling a function (whether or not the function is inline), there is a sequence point after the evaluation
of all function arguments (if any) which takes place before execution of any expressions or statements in
the function body. There is also a sequence point after the copying of a returned value and before the execution
of any expressions outside the function11
(possibly standards-speak for the issue)
YOu ask horrible questions
that I go "hah yes"
then go "hmm, acutally"


Malcolm: Haha.
Why not just redirect the latter to an internal dialogue.
It spoils your Oracular reputation


Matt: Bah
I'm an "Open Oracle"
you see all the working


Malcolm: Hehe
Nice status message.


Matt: The standards is a bit vague to me here
As specified in 12.2, after the "end-of-full-expression" sequence point, a sequence of zero or more invocations of destructor functions
for temporary objects takes place, usually in reverse order of the construction of each temporary object.
sounding like it is actually OK
provided that func1() doesn't keep the const char* around


Malcolm: Hmm.


Matt: /me reads 12.2
complex rules about binding references to temporaries
still reading
"Temporary objects are destroyed as the last step in evaluating
the full-expression (1.9) that (lexically) contains the point where they were created. This is true even
if that evaluation ends in throwing an exception."


Malcolm: is str.c_str() a full-expression?


Matt: that's the next bit


Malcolm: or is func(str.c_str()) the full-expression?


Matt: A full-expression is an expression that is not a subexpression of another expression. If a language construct
is defined to produce an implicit call of a function, a use of the language construct is considered to be an
expression for the purposes of this definition.


Malcolm: I guess that means the latter.


Matt: my interpretation is the same aye
I'm now confused
as func(...) is an expression
so ..str.c_str()... is a subexpression
and so the temporary shouldn't be killed until the outer expression is evaluated
so; I conclude I must've been wrong


Malcolm: Possible.
Though the reason I asked is because I had a feeling it worked as you thought.


Matt: --matt.guru_level;


Malcolm: So we must have had a reason for thinking thaht.
that.


Matt: Yeah
Might be the "if it takes the pointer then it's not in general valid"
whereas it would work (for a while) if it was a pointer to a non-temp object


Malcolm: s/takes/uses?


Matt: takes (for later use)
/me checks PF codebase
(C++ rustiness)
mind you, we tend not to return std::strings ever
mLineNumber = atoi(StringTostdstring(lineDetails).c_str());
Bosh
I did lie
and
sprintf(buffer, "<%s>%s</%s>", child.GetName(), XMLEscape(child.GetText()).c_str(), child.GetName());
So actually another --matt.guru; there


Malcolm: Heh
New blog post for you, though.


Matt: Well, possibly
Shows me up a bit :D
:S


Malcolm: Hah


Matt: careful rewording


Malcolm: You can elide those parts.


Matt: (yourBLOG BLOG)


Malcolm: Though admittedly it's less interesting then.